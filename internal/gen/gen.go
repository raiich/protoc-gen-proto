package gen

import (
	"github.com/raiich/protoc-plugin-template-go/generated/extension"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
)

const (
	ProgramName = "protoc-gen-template-go"

	GeneratedFilenameSuffix = "_custom.pb.proto"
)

var (
	FileDescriptorProtoSyntaxFieldNumber  protoreflect.FieldNumber
	FileDescriptorProtoPackageFieldNumber protoreflect.FieldNumber
)

func init() {
	fields := (*descriptorpb.FileDescriptorProto)(nil).ProtoReflect().Descriptor().Fields()
	FileDescriptorProtoSyntaxFieldNumber = fields.ByName("syntax").Number()
	FileDescriptorProtoPackageFieldNumber = fields.ByName("package").Number()
}

type Info struct {
	*protogen.File
}

func GenerateFile(plugin *protogen.Plugin, file *protogen.File) {
	g := plugin.NewGeneratedFile(
		file.GeneratedFilenamePrefix+GeneratedFilenameSuffix,
		file.GoImportPath,
	)
	d := file.Desc
	g.P("// Code generated by ", ProgramName, ". DO NOT EDIT.")
	g.P()
	g.P("syntax = ", d.Syntax())
	g.P()
	g.P("package ", d.Package())
	g.P()
	for i := 0; i < d.Imports().Len(); i++ {
		g.P("import ", d.Imports().Get(i).Path())
	}
	g.P()
	g.P(d.Options().(*descriptorpb.FileOptions))
	g.P()

	info := &Info{
		File: file,
	}
	for _, enum := range file.Enums {
		generateEnum(g, info, enum)
	}
	for _, message := range file.Messages {
		generateMessage(g, info, message)
	}
	for _, ext := range file.Extensions {
		generateExtension(g, info, ext)
	}
	for _, service := range file.Services {
		g.P(file.Proto.Service[0].Options)
		generateService(g, info, service)
	}
}

func generateEnum(g *protogen.GeneratedFile, info *Info, enum *protogen.Enum) {
	d := enum.Desc
	g.P("enum ", d.Name(), " {")
	g.P(d.Options())
	g.P()
	for _, v := range enum.Values {
		vd := v.Desc
		g.P(vd.Name(), " = ", vd.Number())
	}
	g.P("}")
}

func generateMessage(g *protogen.GeneratedFile, info *Info, message *protogen.Message) {
	d := message.Desc
	g.P("message ", d.Name(), " {")
	g.P(d.Options().(*descriptorpb.MessageOptions))
	g.P()
	g.P()
	d.Fields()
}

func generateExtension(g *protogen.GeneratedFile, info *Info, ext *protogen.Extension) {
	d := ext.Desc
	g.P("extend ", d.Name(), " {")
	d.Number()

}

func generateService(g *protogen.GeneratedFile, info *Info, service *protogen.Service) {
	d := service.Desc
	g.P("service ", d.Name(), " {")
	g.P(d.Options().(*descriptorpb.ServiceOptions))

	opts, ok := proto.GetExtension(service.Desc.Options().(*descriptorpb.ServiceOptions), extension.E_ServiceOpts).(*extension.ServiceOptions)
	if ok {
		g.P("option (", extension.E_ServiceOpts.TypeDescriptor().FullName(), ") = {")
		fields := opts.ProtoReflect().Descriptor().Fields()
		for i := 0; i < fields.Len(); i++ {
			field := fields.Get(i)
			g.P(field.Name(), ": ", opts.ProtoReflect().Get(field).Interface(), ",")
		}
		g.P("};")
	}

	g.P()
	for i, m := range service.Methods {
		if i > 0 {
			g.P()
		}
		generateMethod(g, m)
	}
}

func generateMethod(g *protogen.GeneratedFile, method *protogen.Method) {
	d := method.Desc
	g.P("rpc ", d.Name(), "(", method.Input.Desc.Name(), ") returns (", method.Output.Desc.Name(), ") {")
	g.P(d.Options().(*descriptorpb.MethodOptions))
	opts, ok := proto.GetExtension(method.Desc.Options().(*descriptorpb.MethodOptions), extension.E_MethodOpts).(*extension.MethodOptions)
	if ok {
		g.P("option (", extension.E_MethodOpts.TypeDescriptor().FullName(), ") = {")
		fields := opts.ProtoReflect().Descriptor().Fields()
		for i := 0; i < fields.Len(); i++ {
			field := fields.Get(i)
			g.P(field.Name(), ": ", opts.ProtoReflect().Get(field).Interface(), ",")
		}
		g.P("};")
	}
	g.P("}")
}
