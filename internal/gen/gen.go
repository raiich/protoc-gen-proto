package gen

import (
	"fmt"
	"strconv"
	"strings"

	"github.com/raiich/protoc-plugin-template-go/generated/go/extension"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
)

const (
	ProgramName = "protoc-gen-template-go"

	GeneratedFilenameSuffix = "_custom.pb.proto"
)

var (
	FileDescriptorProtoSyntaxFieldNumber  protoreflect.FieldNumber
	FileDescriptorProtoPackageFieldNumber protoreflect.FieldNumber
)

func init() {
	fields := (*descriptorpb.FileDescriptorProto)(nil).ProtoReflect().Descriptor().Fields()
	FileDescriptorProtoSyntaxFieldNumber = fields.ByName("syntax").Number()
	FileDescriptorProtoPackageFieldNumber = fields.ByName("package").Number()
}

func GenerateFile(plugin *protogen.Plugin, file *protogen.File) {
	var suffix string
	if strings.HasSuffix(GeneratedFilenameSuffix, ".proto") {
		suffix = ".proto"
	}
	g := &GeneratedFile{
		Base: plugin.NewGeneratedFile(
			file.GeneratedFilenamePrefix+suffix,
			file.GoImportPath,
		),
	}
	d := file.Desc
	if suffix != ".proto" {
		g.P("// Code generated by ", ProgramName, ". DO NOT EDIT.")
		g.P()
	}
	g.P("syntax = ", strconv.Quote(d.Syntax().String()), ";")
	g.P()
	g.P("package ", d.Package(), ";")
	for i := 0; i < d.Imports().Len(); i++ {
		if i == 0 {
			g.P()
		}
		g.P("import ", strconv.Quote(d.Imports().Get(i).Path()), ";")
	}
	fileOpts := d.Options().(*descriptorpb.FileOptions)
	if goPackage := fileOpts.GoPackage; goPackage != nil {
		g.P()
		g.P("option go_package = ", strconv.Quote(*goPackage), ";")
	}

	info := &Info{
		File: file,
	}
	for _, service := range file.Services {
		g.P()
		generateService(g, info, service)
	}
	for _, enum := range file.Enums {
		g.P()
		generateEnum(g, info, enum)
	}
	for _, ext := range file.Extensions {
		g.P()
		generateExtension(g, info, ext)
	}
	for _, message := range file.Messages {
		g.P()
		generateMessage(g, info, message)
	}
}

func generateService(g *GeneratedFile, info *Info, s *protogen.Service) {
	d := s.Desc
	g.P("service ", d.Name(), " {")
	defer g.P("}")
	g.WithIndent("  ", func() {
		extInfo := extension.E_ServiceOpts
		ext := proto.GetExtension(d.Options().(*descriptorpb.ServiceOptions), extInfo)
		opts := ext.(*extension.ServiceOpts)
		protoReflect := opts.ProtoReflect()
		fields := protoReflect.Descriptor().Fields()
		switch fields.Len() {
		case 1:
			i := 0
			field := fields.Get(i)
			g.P("option (", info.Ident(extInfo.TypeDescriptor()), ") = {",
				field.Name(), ": ", protoReflect.Get(field),
				"};",
			)
		default:
			panic("implement me")
		}
		for _, m := range s.Methods {
			g.P()
			generateMethod(g, info, m)
		}
	})
}

func generateMethod(g *GeneratedFile, info *Info, m *protogen.Method) {
	d := m.Desc
	g.P("rpc ", d.Name(), "(", info.Ident(m.Input.Desc), ") returns (", info.Ident(m.Output.Desc), ") {")
	defer g.P("}")
	g.WithIndent("  ", func() {
		extInfo := extension.E_MethodOpts
		ext := proto.GetExtension(d.Options().(*descriptorpb.MethodOptions), extInfo)
		opts := ext.(*extension.MethodOpts)
		protoReflect := opts.ProtoReflect()
		fields := protoReflect.Descriptor().Fields()
		switch fields.Len() {
		case 1:
			i := 0
			field := fields.Get(i)
			g.P("option (", info.Ident(extInfo.TypeDescriptor()), ") = {",
				field.Name(), ": ", protoReflect.Get(field),
				"};",
			)
		default:
			panic("implement me")
		}
	})
}

func generateEnum(g *GeneratedFile, info *Info, enum *protogen.Enum) {
	d := enum.Desc
	g.P("enum ", d.Name(), " {")
	g.P(d.Options())
	g.P()
	for _, v := range enum.Values {
		vd := v.Desc
		g.P(vd.Name(), " = ", vd.Number())
	}
	g.P("}")
}

func generateExtension(g *GeneratedFile, info *Info, ext *protogen.Extension) {
	g.P("extend ", info.Ident(ext.Extendee.Desc), " {")
	defer g.P("}")
	g.WithIndent("  ", func() {
		d := ext.Desc
		g.P(info.Ident(ext.Message.Desc), " ", d.Name(), " = ", d.Number(), ";")
	})
}

func generateMessage(g *GeneratedFile, info *Info, message *protogen.Message) {
	d := message.Desc
	g.P("message ", d.Name(), " {")
	defer g.P("}")
	g.WithIndent("  ", func() {
		opts := d.Options().(*descriptorpb.MessageOptions)
		if opts != nil {
			panic("implement me")
		}
		r := message.Desc.ReservedRanges()
		for i := 0; i < r.Len(); i++ {
			ns := r.Get(i)
			from, to := ns[0], ns[1]
			g.P("reserved ", num(from), " to ", num(to), ";")
		}
		for i := 0; i < d.Fields().Len(); i++ {
			field := d.Fields().Get(i)
			optional := ""
			if field.HasOptionalKeyword() {
				optional = "optional "
			}

			var typeName string
			switch field.Kind() {
			case protoreflect.MessageKind:
				typeName = info.Ident(field.Message())
			default:
				typeName = field.Kind().String()
			}
			g.P(optional, typeName, " ", field.Name(), " = ", field.Number(), ";")
		}
	})
}

type GeneratedFile struct {
	Base   *protogen.GeneratedFile
	indent string
}

func (g *GeneratedFile) WithIndent(indent string, f func()) {
	g.indent += indent
	defer func() { g.indent = strings.TrimPrefix(g.indent, indent) }()
	f()
}

func (g *GeneratedFile) P(v ...any) {
	if len(v) == 0 {
		g.Base.P()
		return
	}
	g.Base.P(append([]any{g.indent}, v...)...)
}

func num(n protoreflect.FieldNumber) string {
	if n == 536870912 {
		return "max"
	}
	return fmt.Sprintf("%d", n)
}

type Info struct {
	*protogen.File
}

func (i *Info) Ident(d protoreflect.Descriptor) string {
	if d.FullName().Parent() == i.File.Desc.Package() {
		return string(d.Name())
	}
	return string(d.FullName())
}
